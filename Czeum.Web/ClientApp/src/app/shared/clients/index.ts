/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root'
})
export class AccountsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  register(model: RegisterModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRegister(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegister(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server side error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  changePassword(model: ChangePasswordModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/change-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processChangePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangePassword(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server side error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  confirmEmail(username: string | null | undefined, token: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/confirm-email?";
    if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    if (token !== undefined)
      url_ += "token=" + encodeURIComponent("" + token) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processConfirmEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processConfirmEmail(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processConfirmEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server side error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  getPasswordResetToken(username: string | null | undefined, email: string | null | undefined): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/accounts/reset-password?";
    if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetPasswordResetToken(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPasswordResetToken(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processGetPasswordResetToken(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  resetPassword(model: PasswordResetModel): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/accounts/reset-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processResetPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processResetPassword(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processResetPassword(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  resendConfirmationEmail(email: string | null | undefined): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/accounts/resend-confirm-email?";
    if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processResendConfirmationEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processResendConfirmationEmail(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processResendConfirmationEmail(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  getPersonalData(): Observable<UserInfo> {
    let url_ = this.baseUrl + "/api/accounts/me";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetPersonalData(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPersonalData(<any>response_);
        } catch (e) {
          return <Observable<UserInfo>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserInfo>><any>_observableThrow(response_);
    }));
  }

  protected processGetPersonalData(response: HttpResponseBase): Observable<UserInfo> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <UserInfo>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserInfo>(<any>null);
  }

  userNameAvailable(username: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/accounts/username-available?";
    if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUserNameAvailable(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserNameAvailable(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processUserNameAvailable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  emailAvailable(email: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/accounts/email-available?";
    if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processEmailAvailable(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processEmailAvailable(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processEmailAvailable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  getUsernames(username: string | null | undefined): Observable<UserDto[]> {
    let url_ = this.baseUrl + "/api/accounts?";
    if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetUsernames(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUsernames(<any>response_);
        } catch (e) {
          return <Observable<UserDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetUsernames(response: HttpResponseBase): Observable<UserDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <UserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserDto[]>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class AchivetmentsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getAchivements(): Observable<AchivementDto[]> {
    let url_ = this.baseUrl + "/api/achivements";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAchivements(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAchivements(<any>response_);
        } catch (e) {
          return <Observable<AchivementDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<AchivementDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAchivements(response: HttpResponseBase): Observable<AchivementDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <AchivementDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<AchivementDto[]>(<any>null);
  }

  starAchivement(id: string): Observable<AchivementDto> {
    let url_ = this.baseUrl + "/api/achivements/{id}/star";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processStarAchivement(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStarAchivement(<any>response_);
        } catch (e) {
          return <Observable<AchivementDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<AchivementDto>><any>_observableThrow(response_);
    }));
  }

  protected processStarAchivement(response: HttpResponseBase): Observable<AchivementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <AchivementDto>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<AchivementDto>(<any>null);
  }

  unstarAchivement(id: string): Observable<AchivementDto> {
    let url_ = this.baseUrl + "/api/achivements/{id}/unstar";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUnstarAchivement(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUnstarAchivement(<any>response_);
        } catch (e) {
          return <Observable<AchivementDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<AchivementDto>><any>_observableThrow(response_);
    }));
  }

  protected processUnstarAchivement(response: HttpResponseBase): Observable<AchivementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <AchivementDto>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<AchivementDto>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LobbiesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getLobbies(): Observable<LobbyDataWrapper[]> {
    let url_ = this.baseUrl + "/api/lobbies";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetLobbies(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetLobbies(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetLobbies(response: HttpResponseBase): Observable<LobbyDataWrapper[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper[]>(<any>null);
  }

  createLobby(dto: CreateLobbyDto): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(dto);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreateLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateLobby(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processCreateLobby(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        result201 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  getLobby(id: string): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetLobby(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processGetLobby(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  getCurrentLobby(): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetCurrentLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCurrentLobby(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processGetCurrentLobby(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  updateLobby(wrapper: LobbyDataWrapper, lobbyId: string): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{lobbyId}";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(wrapper);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdateLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateLobby(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateLobby(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  leaveLobby(): Observable<void> {
    let url_ = this.baseUrl + "/api/lobbies/current/leave";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLeaveLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLeaveLobby(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processLeaveLobby(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  invitePlayer(lobbyId: string, playerName: string | null | undefined): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{lobbyId}/invite?";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    if (playerName !== undefined)
      url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvitePlayer(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvitePlayer(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processInvitePlayer(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  cancelInvitation(lobbyId: string, playerName: string | null | undefined): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{lobbyId}/invite?";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    if (playerName !== undefined)
      url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCancelInvitation(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCancelInvitation(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processCancelInvitation(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  joinLobby(lobbyId: string): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{lobbyId}/join";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processJoinLobby(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processJoinLobby(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processJoinLobby(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }

  kickGuest(lobbyId: string, guestName: string | null): Observable<LobbyDataWrapper> {
    let url_ = this.baseUrl + "/api/lobbies/{lobbyId}/kick/{guestName}";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    if (guestName === undefined || guestName === null)
      throw new Error("The parameter 'guestName' must be defined.");
    url_ = url_.replace("{guestName}", encodeURIComponent("" + guestName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processKickGuest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processKickGuest(<any>response_);
        } catch (e) {
          return <Observable<LobbyDataWrapper>><any>_observableThrow(e);
        }
      } else
        return <Observable<LobbyDataWrapper>><any>_observableThrow(response_);
    }));
  }

  protected processKickGuest(response: HttpResponseBase): Observable<LobbyDataWrapper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <LobbyDataWrapper>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<LobbyDataWrapper>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class MatchesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getGameTypes(): Observable<GameTypeDto[]> {
    let url_ = this.baseUrl + "/api/matches/types";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetGameTypes(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetGameTypes(<any>response_);
        } catch (e) {
          return <Observable<GameTypeDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<GameTypeDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetGameTypes(response: HttpResponseBase): Observable<GameTypeDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <GameTypeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GameTypeDto[]>(<any>null);
  }

  getMatches(): Observable<MatchStatus[]> {
    let url_ = this.baseUrl + "/api/matches";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMatches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMatches(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetMatches(response: HttpResponseBase): Observable<MatchStatus[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MatchStatus[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus[]>(<any>null);
  }

  createMatch(lobbyId: string | undefined): Observable<MatchStatus> {
    let url_ = this.baseUrl + "/api/matches?";
    if (lobbyId === null)
      throw new Error("The parameter 'lobbyId' cannot be null.");
    else if (lobbyId !== undefined)
      url_ += "lobbyId=" + encodeURIComponent("" + lobbyId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreateMatch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateMatch(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processCreateMatch(response: HttpResponseBase): Observable<MatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        result201 = _responseText === "" ? null : <MatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus>(<any>null);
  }

  getCurrentMatches(oldestId: string | null | undefined, count: number | undefined): Observable<RollListDtoOfMatchStatus> {
    let url_ = this.baseUrl + "/api/matches/current?";
    if (oldestId !== undefined)
      url_ += "oldestId=" + encodeURIComponent("" + oldestId) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetCurrentMatches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCurrentMatches(<any>response_);
        } catch (e) {
          return <Observable<RollListDtoOfMatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<RollListDtoOfMatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processGetCurrentMatches(response: HttpResponseBase): Observable<RollListDtoOfMatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <RollListDtoOfMatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RollListDtoOfMatchStatus>(<any>null);
  }

  getFinishedMatches(oldestId: string | null | undefined, count: number | undefined): Observable<RollListDtoOfMatchStatus> {
    let url_ = this.baseUrl + "/api/matches/finished?";
    if (oldestId !== undefined)
      url_ += "oldestId=" + encodeURIComponent("" + oldestId) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFinishedMatches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFinishedMatches(<any>response_);
        } catch (e) {
          return <Observable<RollListDtoOfMatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<RollListDtoOfMatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processGetFinishedMatches(response: HttpResponseBase): Observable<RollListDtoOfMatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <RollListDtoOfMatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RollListDtoOfMatchStatus>(<any>null);
  }

  move(moveDataWrapper: MoveDataWrapper): Observable<MatchStatus> {
    let url_ = this.baseUrl + "/api/matches/moves";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(moveDataWrapper);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processMove(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMove(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processMove(response: HttpResponseBase): Observable<MatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        result400 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus>(<any>null);
  }

  voteForDraw(matchId: string): Observable<MatchStatus> {
    let url_ = this.baseUrl + "/api/matches/{matchId}/call-draw";
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processVoteForDraw(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processVoteForDraw(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processVoteForDraw(response: HttpResponseBase): Observable<MatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        result403 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus>(<any>null);
  }

  resign(matchId: string): Observable<MatchStatus> {
    let url_ = this.baseUrl + "/api/matches/{matchId}/resign";
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processResign(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processResign(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processResign(response: HttpResponseBase): Observable<MatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        result403 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus>(<any>null);
  }

  getMatch(matchId: string): Observable<MatchStatus> {
    let url_ = this.baseUrl + "/api/matches/{matchId}";
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMatch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMatch(<any>response_);
        } catch (e) {
          return <Observable<MatchStatus>><any>_observableThrow(e);
        }
      } else
        return <Observable<MatchStatus>><any>_observableThrow(response_);
    }));
  }

  protected processGetMatch(response: HttpResponseBase): Observable<MatchStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MatchStatus>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        result403 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MatchStatus>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class NotificationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getNotifications(): Observable<NotificationDto[]> {
    let url_ = this.baseUrl + "/api/notifications";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetNotifications(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetNotifications(<any>response_);
        } catch (e) {
          return <Observable<NotificationDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetNotifications(response: HttpResponseBase): Observable<NotificationDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <NotificationDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationDto[]>(<any>null);
  }

  deleteNotification(id: string): Observable<void> {
    let url_ = this.baseUrl + "/api/notifications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDeleteNotification(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteNotification(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class SoloQueueClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  joinQueue(): Observable<void> {
    let url_ = this.baseUrl + "/api/solo-queue/join";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processJoinQueue(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processJoinQueue(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processJoinQueue(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  leaveQueue(): Observable<void> {
    let url_ = this.baseUrl + "/api/solo-queue/leave";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLeaveQueue(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLeaveQueue(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processLeaveQueue(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class StatisticsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getStatistics(): Observable<StatisticsDto> {
    let url_ = this.baseUrl + "/api/statistics";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetStatistics(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetStatistics(<any>response_);
        } catch (e) {
          return <Observable<StatisticsDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<StatisticsDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetStatistics(response: HttpResponseBase): Observable<StatisticsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <StatisticsDto>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<StatisticsDto>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class DirectMessagesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getMessages(friendshipId: string, oldestId: string | null | undefined, count: number | undefined): Observable<RollListDtoOfMessage> {
    let url_ = this.baseUrl + "/api/messages/{friendshipId}?";
    if (friendshipId === undefined || friendshipId === null)
      throw new Error("The parameter 'friendshipId' must be defined.");
    url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
    if (oldestId !== undefined)
      url_ += "oldestId=" + encodeURIComponent("" + oldestId) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMessages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMessages(<any>response_);
        } catch (e) {
          return <Observable<RollListDtoOfMessage>><any>_observableThrow(e);
        }
      } else
        return <Observable<RollListDtoOfMessage>><any>_observableThrow(response_);
    }));
  }

  protected processGetMessages(response: HttpResponseBase): Observable<RollListDtoOfMessage> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <RollListDtoOfMessage>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        result403 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RollListDtoOfMessage>(<any>null);
  }

  sendMessage(friendshipId: string, message: string): Observable<Message> {
    let url_ = this.baseUrl + "/api/messages/{friendshipId}";
    if (friendshipId === undefined || friendshipId === null)
      throw new Error("The parameter 'friendshipId' must be defined.");
    url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(message);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSendMessage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendMessage(<any>response_);
        } catch (e) {
          return <Observable<Message>><any>_observableThrow(e);
        }
      } else
        return <Observable<Message>><any>_observableThrow(response_);
    }));
  }

  protected processSendMessage(response: HttpResponseBase): Observable<Message> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <Message>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        result403 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Message>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class LobbyMessagesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getMessages(lobbyId: string, oldestId: string | null | undefined, count: number | undefined): Observable<RollListDtoOfMessage> {
    let url_ = this.baseUrl + "/api/messages/lobby/{lobbyId}?";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    if (oldestId !== undefined)
      url_ += "oldestId=" + encodeURIComponent("" + oldestId) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMessages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMessages(<any>response_);
        } catch (e) {
          return <Observable<RollListDtoOfMessage>><any>_observableThrow(e);
        }
      } else
        return <Observable<RollListDtoOfMessage>><any>_observableThrow(response_);
    }));
  }

  protected processGetMessages(response: HttpResponseBase): Observable<RollListDtoOfMessage> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <RollListDtoOfMessage>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RollListDtoOfMessage>(<any>null);
  }

  sendMessage(lobbyId: string, message: string): Observable<Message> {
    let url_ = this.baseUrl + "/api/messages/lobby/{lobbyId}";
    if (lobbyId === undefined || lobbyId === null)
      throw new Error("The parameter 'lobbyId' must be defined.");
    url_ = url_.replace("{lobbyId}", encodeURIComponent("" + lobbyId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(message);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSendMessage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendMessage(<any>response_);
        } catch (e) {
          return <Observable<Message>><any>_observableThrow(e);
        }
      } else
        return <Observable<Message>><any>_observableThrow(response_);
    }));
  }

  protected processSendMessage(response: HttpResponseBase): Observable<Message> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <Message>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Message>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class MatchMessagesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getMessages(matchId: string, oldestId: string | null | undefined, count: number | undefined): Observable<RollListDtoOfMessage> {
    let url_ = this.baseUrl + "/api/messages/match/{matchId}?";
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    if (oldestId !== undefined)
      url_ += "oldestId=" + encodeURIComponent("" + oldestId) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMessages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMessages(<any>response_);
        } catch (e) {
          return <Observable<RollListDtoOfMessage>><any>_observableThrow(e);
        }
      } else
        return <Observable<RollListDtoOfMessage>><any>_observableThrow(response_);
    }));
  }

  protected processGetMessages(response: HttpResponseBase): Observable<RollListDtoOfMessage> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <RollListDtoOfMessage>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RollListDtoOfMessage>(<any>null);
  }

  sendMessage(matchId: string, message: string): Observable<Message> {
    let url_ = this.baseUrl + "/api/messages/match/{matchId}";
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(message);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSendMessage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendMessage(<any>response_);
        } catch (e) {
          return <Observable<Message>><any>_observableThrow(e);
        }
      } else
        return <Observable<Message>><any>_observableThrow(response_);
    }));
  }

  protected processSendMessage(response: HttpResponseBase): Observable<Message> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <Message>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Message>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class FriendRequestsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getFriendRequestsReceived(): Observable<FriendRequestDto[]> {
    let url_ = this.baseUrl + "/api/friends/friend-requests/received";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFriendRequestsReceived(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFriendRequestsReceived(<any>response_);
        } catch (e) {
          return <Observable<FriendRequestDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<FriendRequestDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetFriendRequestsReceived(response: HttpResponseBase): Observable<FriendRequestDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <FriendRequestDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FriendRequestDto[]>(<any>null);
  }

  getFriendRequestsSent(): Observable<FriendRequestDto[]> {
    let url_ = this.baseUrl + "/api/friends/friend-requests/sent";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFriendRequestsSent(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFriendRequestsSent(<any>response_);
        } catch (e) {
          return <Observable<FriendRequestDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<FriendRequestDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetFriendRequestsSent(response: HttpResponseBase): Observable<FriendRequestDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <FriendRequestDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FriendRequestDto[]>(<any>null);
  }

  sendFriendRequest(userId: string): Observable<FriendRequestDto> {
    let url_ = this.baseUrl + "/api/friends/friend-requests/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSendFriendRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendFriendRequest(<any>response_);
        } catch (e) {
          return <Observable<FriendRequestDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<FriendRequestDto>><any>_observableThrow(response_);
    }));
  }

  protected processSendFriendRequest(response: HttpResponseBase): Observable<FriendRequestDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        result201 = _responseText === "" ? null : <FriendRequestDto>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result201);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FriendRequestDto>(<any>null);
  }

  cancelFriendRequest(requestId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/friends/friend-requests/{requestId}/cancel";
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCancelFriendRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCancelFriendRequest(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processCancelFriendRequest(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  rejectFriendRequest(requestId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/friends/friend-requests/{requestId}/reject";
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRejectFriendRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRejectFriendRequest(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processRejectFriendRequest(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable({
  providedIn: 'root'
})
export class FriendshipsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  getFriends(): Observable<FriendDto[]> {
    let url_ = this.baseUrl + "/api/friends/friendships";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFriends(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFriends(<any>response_);
        } catch (e) {
          return <Observable<FriendDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<FriendDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetFriends(response: HttpResponseBase): Observable<FriendDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <FriendDto[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FriendDto[]>(<any>null);
  }

  removeFriend(friendshipId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/friends/friendships/{friendshipId}";
    if (friendshipId === undefined || friendshipId === null)
      throw new Error("The parameter 'friendshipId' must be defined.");
    url_ = url_.replace("{friendshipId}", encodeURIComponent("" + friendshipId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRemoveFriend(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRemoveFriend(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processRemoveFriend(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  acceptRequest(requestId: string): Observable<FriendDto> {
    let url_ = this.baseUrl + "/api/friends/friendships/{requestId}";
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAcceptRequest(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAcceptRequest(<any>response_);
        } catch (e) {
          return <Observable<FriendDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<FriendDto>><any>_observableThrow(response_);
    }));
  }

  protected processAcceptRequest(response: HttpResponseBase): Observable<FriendDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        result201 = _responseText === "" ? null : <FriendDto>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result201);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FriendDto>(<any>null);
  }
}

export interface ProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any; } | undefined;
}

export interface RegisterModel {
  username?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;
}

export interface ChangePasswordModel {
  oldPassword?: string | undefined;
  password?: string | undefined;
}

export interface PasswordResetModel {
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
}

export interface UserInfo {
  id: string;
  username?: string | undefined;
  email?: string | undefined;
}

export interface UserDto {
  id: string;
  username?: string | undefined;
}

export interface AchivementDto {
  id: string;
  title?: string | undefined;
  description?: string | undefined;
  isStarred: boolean;
  unlockedAt: Date;
}

export interface WrapperOfLobbyData {
  gameIdentifier: number;
  content?: LobbyData | undefined;
}

export interface LobbyDataWrapper extends WrapperOfLobbyData {
}

export interface LobbyData {
  id: string;
  name?: string | undefined;
  host?: string | undefined;
  guests?: string[] | undefined;
  access: LobbyAccess;
  invitedPlayers?: string[] | undefined;
  empty: boolean;
  created: Date;
  lastModified: Date;
}

export enum LobbyAccess {
  Public = 0,
  Private = 1,
  FriendsOnly = 2,
}

export interface CreateLobbyDto {
  gameIdentifier: number;
  lobbyAccess: LobbyAccess;
  name?: string | undefined;
}

export interface GameTypeDto {
  identifier: number;
  displayName?: string | undefined;
}

export interface MatchStatus {
  id: string;
  currentPlayerIndex: number;
  playerIndex: number;
  players?: Player[] | undefined;
  currentBoard?: MoveResultWrapper | undefined;
  state: GameState;
  winner?: string | undefined;
  createDate: Date;
  lastMoveDate?: Date | undefined;
}

export interface Player {
  username?: string | undefined;
  playerIndex: number;
  votesForDraw: boolean;
  resigned: boolean;
}

export interface WrapperOfIMoveResult {
  gameIdentifier: number;
  content?: IMoveResult | undefined;
}

export interface MoveResultWrapper extends WrapperOfIMoveResult {
}

export interface IMoveResult {
}

export enum GameState {
  YourTurn = 0,
  EnemyTurn = 1,
  Won = 2,
  Lost = 3,
  Draw = 4,
}

export interface RollListDtoOfMatchStatus {
  hasMoreLeft: boolean;
  data?: MatchStatus[] | undefined;
}

export interface WrapperOfMoveData {
  gameIdentifier: number;
  content?: MoveData | undefined;
}

export interface MoveDataWrapper extends WrapperOfMoveData {
}

export interface MoveData {
  matchId: string;
}

export interface NotificationDto {
  id: string;
  type: NotificationType;
  senderUserName?: string | undefined;
  data?: string | undefined;
}

export enum NotificationType {
  InviteReceived = 0,
  FriendRequestReceived = 1,
  Poked = 2,
  FriendRequestAccepted = 3,
  AchivementUnlocked = 4,
}

export interface StatisticsDto {
  playedGames: number;
  wonGames: number;
  favouriteGame?: GameTypeDto | undefined;
  playedGamesOfFavourite: number;
  wonGamesOfFavourite: number;
  mostPlayedWithName?: string | undefined;
}

export interface RollListDtoOfMessage {
  hasMoreLeft: boolean;
  data?: Message[] | undefined;
}

export interface Message {
  id: string;
  sender?: string | undefined;
  text?: string | undefined;
  timestamp: Date;
}

export interface FriendRequestDto {
  id: string;
  senderName?: string | undefined;
  receiverName?: string | undefined;
  sentAt: Date;
}

export interface FriendDto {
  friendshipId: string;
  isOnline: boolean;
  username?: string | undefined;
  lastDisconnect: Date;
  registrationTime: Date;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
